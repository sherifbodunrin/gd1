<script>
    // Boss shooting patterns
    let bossShootingInterval;

    function setRandomBossShootingPattern() {
        const patterns = [fasterRandomSpread, alternatingRadialBurst, targetedShotBarrage, spiralPattern];
        const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
        randomPattern(); // Execute the selected shooting pattern
    }

    // 1. Faster Random Spread
    function fasterRandomSpread() {
        bossShootingInterval = setInterval(() => {
            if (isGameOver) return;

            for (let i = 0; i < 5; i++) { // Fire more bullets at once
                const angle = Math.random() * Math.PI * 2;
                const velocityX = Math.cos(angle) * 7; // Increased speed
                const velocityY = Math.sin(angle) * 7;

                const bossBullet = new Konva.Circle({
                    x: boss.x() + boss.width() / 2,
                    y: boss.y() + boss.height() / 2,
                    radius: 5,
                    fill: 'red'
                });
                layer.add(bossBullet);
                bossBullet.hasDamagedPlayer = false;

                const anim = new Konva.Animation(() => {
                    bossBullet.x(bossBullet.x() + velocityX);
                    bossBullet.y(bossBullet.y() + velocityY);

                    // Collision detection with player
                    if (!bossBullet.hasDamagedPlayer &&
                        bossBullet.y() >= player.y() - 30 &&
                        bossBullet.y() <= player.y() + 30 &&
                        bossBullet.x() >= player.x() - 30 &&
                        bossBullet.x() <= player.x() + 30) {
                        updatePlayerHp(15); // Increased damage
                        bossBullet.hasDamagedPlayer = true;
                        bossBullet.destroy();
                    }

                    if (bossBullet.y() > stage.height() || bossBullet.y() < 0 ||
                        bossBullet.x() > stage.width() || bossBullet.x() < 0) {
                        bossBullet.destroy();
                    }
                }, layer);
                anim.start();
            }
        }, 800); // Shoot more frequently
    }

    // 2. Alternating Radial Burst
    function alternatingRadialBurst() {
        let alternate = false;
        bossShootingInterval = setInterval(() => {
            if (isGameOver) return;

            const burstCount = alternate ? 12 : 16; // Alternate between 12 and 16 bullets
            const speed = alternate ? 4 : 6; // Alternate speed for variation
            alternate = !alternate;

            for (let i = 0; i < burstCount; i++) {
                const angle = (Math.PI * 2) / burstCount * i;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;

                const bossBullet = new Konva.Circle({
                    x: boss.x() + boss.width() / 2,
                    y: boss.y() + boss.height() / 2,
                    radius: 6,
                    fill: 'red'
                });
                layer.add(bossBullet);
                bossBullet.hasDamagedPlayer = false;

                const anim = new Konva.Animation(() => {
                    bossBullet.x(bossBullet.x() + velocityX);
                    bossBullet.y(bossBullet.y() + velocityY);

                    // Collision detection with player
                    if (!bossBullet.hasDamagedPlayer &&
                        bossBullet.y() >= player.y() - 30 &&
                        bossBullet.y() <= player.y() + 30 &&
                        bossBullet.x() >= player.x() - 30 &&
                        bossBullet.x() <= player.x() + 30) {
                        updatePlayerHp(10);
                        bossBullet.hasDamagedPlayer = true;
                        bossBullet.destroy();
                    }

                    if (bossBullet.y() > stage.height() || bossBullet.y() < 0 ||
                        bossBullet.x() > stage.width() || bossBullet.x() < 0) {
                        bossBullet.destroy();
                    }
                }, layer);
                anim.start();
            }
        }, 1500); // Alternate bursts every 1.5 seconds
    }

    // 3. Targeted Shot Barrage
    function targetedShotBarrage() {
        bossShootingInterval = setInterval(() => {
            if (isGameOver) return;

            for (let i = 0; i < 3; i++) { // Shoot 3 bullets toward the player
                const dx = player.x() - (boss.x() + boss.width() / 2);
                const dy = player.y() - (boss.y() + boss.height() / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                const velocityX = (dx / distance) * 6; // Increased speed
                const velocityY = (dy / distance) * 6;

                const bossBullet = new Konva.Circle({
                    x: boss.x() + boss.width() / 2,
                    y: boss.y() + boss.height() / 2,
                    radius: 7,
                    fill: 'red'
                });
                layer.add(bossBullet);
                bossBullet.hasDamagedPlayer = false;

                const anim = new Konva.Animation(() => {
                    bossBullet.x(bossBullet.x() + velocityX);
                    bossBullet.y(bossBullet.y() + velocityY);

                    // Collision detection with player
                    if (!bossBullet.hasDamagedPlayer &&
                        bossBullet.y() >= player.y() - 30 &&
                        bossBullet.y() <= player.y() + 30 &&
                        bossBullet.x() >= player.x() - 30 &&
                        bossBullet.x() <= player.x() + 30) {
                        updatePlayerHp(20); // Higher damage for barrage
                        bossBullet.hasDamagedPlayer = true;
                        bossBullet.destroy();
                    }

                    if (bossBullet.y() > stage.height() || bossBullet.y() < 0 ||
                        bossBullet.x() > stage.width() || bossBullet.x() < 0) {
                        bossBullet.destroy();
                    }
                }, layer);
                anim.start();

                // Delay between each barrage shot
                setTimeout(() => {}, 200);
            }
        }, 1000); // Barrage every second
    }

    // 4. Spiral Pattern
    function spiralPattern() {
        let angleOffset = 0;
        bossShootingInterval = setInterval(() => {
            if (isGameOver) return;

            for (let i = 0; i < 15; i++) { // More bullets for a denser spiral
                const angle = (Math.PI * 2) / 15 * i + angleOffset; // Shift angle for spiral effect
                const velocityX = Math.cos(angle) * 4;
                const velocityY = Math.sin(angle) * 4;

                const bossBullet = new Konva.Circle({
                    x: boss.x() + boss.width() / 2,
                    y: boss.y() + boss.height() / 2,
                    radius: 5,
                    fill: 'red'
                });
                layer.add(bossBullet);
                bossBullet.hasDamagedPlayer = false;

                const anim = new Konva.Animation(() => {
                    bossBullet.x(bossBullet.x() + velocityX);
                    bossBullet.y(bossBullet.y() + velocityY);

                    // Collision detection with player
                    if (!bossBullet.hasDamagedPlayer &&
                        bossBullet.y() >= player.y() - 30 &&
                        bossBullet.y() <= player.y() + 30 &&
                        bossBullet.x() >= player.x() - 30 &&
                        bossBullet.x() <= player.x() + 30) {
                        updatePlayerHp(10);
                        bossBullet.hasDamagedPlayer = true;
                        bossBullet.destroy();
                    }

                    if (bossBullet.y() > stage.height() || bossBullet.y() < 0 ||
                        bossBullet.x() > stage.width() || bossBullet.x() < 0) {
                        bossBullet.destroy();
                    }
                }, layer);
                anim.start();
            }

            angleOffset += 0.1; // Gradually increase offset for spiral effect
        }, 100); // Tight spiral every 0.1 seconds
    }

    // Start with a random harder shooting pattern
    setRandomBossShootingPattern();
</script>
