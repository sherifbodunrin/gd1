<script src="https://cdn.jsdelivr.net/npm/konva@8.3.0/konva.min.js"></script>
<div id="container"></div>
<script>
  const stage = new Konva.Stage({
    container: 'container',
    width: window.innerWidth,
    height: window.innerHeight
  });
  const layer = new Konva.Layer();
  stage.add(layer);

  // Player represented as a blue circle
  const player = new Konva.Circle({
    x: stage.width() / 2,
    y: stage.height() - 50,
    radius: 30,
    fill: 'blue'
  });
  layer.add(player);

  // Initialize level
  let level = 1;

  // Function to create a boss with a different color and shooting pattern
  let bossHp;
  let boss;
  let bossHpBar;

  function spawnNewBoss() {
    const bossColors = ['red', 'green', 'orange', 'purple', 'cyan'];
    const randomColor = bossColors[Math.floor(Math.random() * bossColors.length)];

    boss = new Konva.Rect({
      x: stage.width() / 2 - 50,
      y: 50,
      width: 100,
      height: 100,
      fill: randomColor
    });
    layer.add(boss);

    bossHp = 100;
    bossHpBar = new Konva.Rect({
      x: boss.x(),
      y: boss.y() - 20, // Position above the boss
      width: bossHp, // Boss HP starts at 100
      height: 10,
      fill: 'green'
    });
    layer.add(bossHpBar);

    layer.batchDraw();
  }

  // Spawn the first boss
  spawnNewBoss();

  // Level text
  const levelText = new Konva.Text({
    x: stage.width() / 2 - 50,
    y: 10,
    text: `Level ${level}`,
    fontSize: 24,
    fill: 'black' // Set text to black
  });
  layer.add(levelText);

  // Player HP Bar (below the player)
  let playerHp = 100;
  const playerHpBar = new Konva.Rect({
    x: player.x() - 30,
    y: player.y() + 40, // Position below the player
    width: playerHp, // Player HP starts at 100
    height: 10,
    fill: 'green'
  });
  layer.add(playerHpBar);

  // Function to update Boss HP Bar
  function updateBossHp(damage) {
    bossHp = Math.max(0, bossHp - damage); // Reduce boss HP
    bossHpBar.width(bossHp); // Update HP bar width
    if (bossHp === 0) {
      console.log('Boss defeated!');
      boss.destroy(); // Remove the old boss
      bossHpBar.destroy(); // Remove the old boss HP bar
      level++; // Increase the level
      levelText.text(`Level ${level}`); // Update the level text
      spawnNewBoss(); // Spawn a new boss
    }
    layer.batchDraw();
  }

  // Function to update Player HP Bar
  function updatePlayerHp(damage) {
    playerHp = Math.max(0, playerHp - damage); // Reduce player HP
    playerHpBar.width(playerHp); // Update HP bar width
    if (playerHp === 0) {
      console.log('Player defeated!');
    }
    layer.batchDraw();
  }

  // Bullet shooting function (Player)
  function shootBullet() {
    const bullet = new Konva.Circle({
      x: player.x(),
      y: player.y() - 30,
      radius: 5,
      fill: 'red'
    });
    layer.add(bullet);

    // Bullet movement animation
    const anim = new Konva.Animation(() => {
      bullet.y(bullet.y() - 10);

      // Check for collision with the boss
      if (bullet.y() <= boss.y() + boss.height() &&
          bullet.y() >= boss.y() &&
          bullet.x() >= boss.x() &&
          bullet.x() <= boss.x() + boss.width()) {
        updateBossHp(2); // Deal 2 damage to the boss
        bullet.destroy(); // Destroy the bullet upon collision
      }

      if (bullet.y() < 0) {
        bullet.destroy(); // Remove bullet if it leaves the screen
      }
    }, layer);
    anim.start();
  }

  // Smoother arrow key movement with disabling default behavior
  const keysPressed = {};

  window.addEventListener('keydown', (e) => {
    keysPressed[e.key] = true;

    // Prevent the default scrolling behavior for arrow keys and space
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
      e.preventDefault();
    }

    // Event listener for space bar to shoot bullets
    if (e.key === ' ') {
      shootBullet();
    }
  });

  window.addEventListener('keyup', (e) => {
    keysPressed[e.key] = false;
  });

  function movePlayer() {
    if (keysPressed['ArrowLeft']) {
      player.x(player.x() - 5); // Move left
      playerHpBar.x(player.x() - 30); // Keep HP bar aligned with player
    }
    if (keysPressed['ArrowRight']) {
      player.x(player.x() + 5); // Move right
      playerHpBar.x(player.x() - 30); // Keep HP bar aligned with player
    }
    if (keysPressed['ArrowUp']) {
      player.y(player.y() - 5); // Move up
      playerHpBar.y(player.y() + 40); // Keep HP bar aligned with player
    }
    if (keysPressed['ArrowDown']) {
      player.y(player.y() + 5); // Move down
      playerHpBar.y(player.y() + 40); // Keep HP bar aligned with player
    }

    // Boundaries to prevent the player from going off-screen
    if (player.x() < 0) player.x(0); // Prevent going off screen (left)
    if (player.x() > stage.width()) player.x(stage.width()); // Prevent going off screen (right)
    if (player.y() < 0) player.y(0); // Prevent going off screen (top)
    if (player.y() > stage.height()) player.y(stage.height()); // Prevent going off screen (bottom)

    layer.batchDraw(); // Redraw the layer to update player position
  }

  // Call movePlayer function every 16ms (60 frames per second)
  setInterval(movePlayer, 16); // 60 FPS

  // Boss bullet patterns and damage to player
  function shootStraightBullets() {
    for (let i = 0; i < 5 + level; i++) { // Increase bullet count with level
      const bullet = new Konva.Circle({
        x: boss.x() + 20 * i,
        y: boss.y() + boss.height(),
        radius: 5,
        fill: 'yellow'
      });
      layer.add(bullet);

      // Bullet movement animation (straight down)
      const anim = new Konva.Animation(() => {
        bullet.y(bullet.y() + 5 + level); // Increase speed with level

        // Check for collision with the player
        if (bullet.y() >= player.y() - player.radius() &&
            bullet.x() >= player.x() - player.radius() &&
            bullet.x() <= player.x() + player.radius()) {
          updatePlayerHp(2); // Deal 2 damage to the player
          bullet.destroy(); // Destroy the bullet upon collision
        }

        if (bullet.y() > stage.height()) {
          bullet.destroy(); // Remove bullet if it leaves the screen
        }
      }, layer);
      anim.start();
    }
  }

  function shootCircularBullets() {
    const numBullets = 12 + level; // Increase bullet count with level
    const angleStep = (2 * Math.PI) / numBullets;

    for (let i = 0; i < numBullets; i++) {
      const angle = i * angleStep;
      const bullet = new Konva.Circle({
        x: boss.x() + boss.width() / 2,
        y: boss.y() + boss.height() / 2,
        radius: 5,
        fill: 'orange'
      });
      layer.add(bullet);

      // Bullet movement in circular pattern
      const anim = new Konva.Animation(() => {
        bullet.x(bullet.x() + Math.cos(angle) * 3);
        bullet.y(bullet.y() + Math.sin(angle) * 3);

        // Check for collision with the player
        if (bullet.y() >= player.y() - player.radius() &&
            bullet.x() >= player.x() - player.radius() &&
            bullet.x() <= player.x() + player.radius()) {
          updatePlayerHp(2); // Deal 2 damage to the player
          bullet.destroy(); // Destroy the bullet upon collision
        }

        if (bullet.y() > stage.height() || bullet.x() < 0 || bullet.x() > stage.width()) {
          bullet.destroy(); // Remove bullet if it leaves the screen
        }
      }, layer);
      anim.start();
    }
  }

  function shootWaveBullets() {
    for (let i = 0; i < 8 + level; i++) { // Increase bullet count with level
      const bullet = new Konva.Circle({
        x: boss.x() + boss.width() / 2 + i * 15,
        y: boss.y() + boss.height(),
        radius: 5,
        fill: 'purple'
      });
      layer.add(bullet);

      // Bullet movement in a wave pattern
      const anim = new Konva.Animation(() => {
        bullet.y(bullet.y() + 5);
        bullet.x(bullet.x() + Math.sin(bullet.y() / 20) * 10); // Wave motion

        // Check for collision with the player
        if (bullet.y() >= player.y() - player.radius() &&
            bullet.x() >= player.x() - player.radius() &&
            bullet.x() <= player.x() + player.radius()) {
          updatePlayerHp(2); // Deal 2 damage to the player
          bullet.destroy(); // Destroy the bullet upon collision
        }

        if (bullet.y() > stage.height()) {
          bullet.destroy(); // Remove bullet if it leaves the screen
        }
      }, layer);
      anim.start();
    }
  }

  // Function to randomly choose bullet patterns
  function bossShoot() {
    const randomPattern = Math.floor(Math.random() * 3); // Choose between 3 patterns

    if (randomPattern === 0) {
      shootStraightBullets();
    } else if (randomPattern === 1) {
      shootCircularBullets();
    } else {
      shootWaveBullets();
    }
  }

  // Make the boss shoot bullets every 2 seconds
  setInterval(bossShoot, 2000);

  // Redraw the layer
  layer.draw();
</script>
