let lastTime = 0;
let elapsedTime = 0;

// Modify the game loop to track time and update distance accordingly
function gameLoop(timestamp) {
  if (lastTime === 0) lastTime = timestamp;
  const deltaTime = timestamp - lastTime;
  lastTime = timestamp;
  elapsedTime += deltaTime;

  if (gameOver) {
    alert("Game Over! Refresh to play again.");
    return;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update distance based on elapsed time (1 second = 1000 milliseconds)
  if (elapsedTime >= 1000) {
    distance++;
    elapsedTime = 0; // Reset elapsed time
  }

  // Gradually increase game speed with a cap
  if (distance % 100 === 0 && gameSpeed < maxGameSpeed) {
    gameSpeed += 0.01; // Smaller increments for more gradual speed increase
  }

  // Draw ground
  ctx.fillStyle = 'black';
  ctx.fillRect(0, canvas.height - 100, canvas.width, 10);

  // Draw player
  ctx.fillStyle = 'blue';
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Draw obstacles
  ctx.fillStyle = 'red';
  obstacles.forEach((obstacle, index) => {
    obstacle.x -= gameSpeed;
    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

    // Collision detection for ground obstacles
    if (
      player.x < obstacle.x + obstacle.width &&
      player.x + player.width > obstacle.x &&
      player.y < obstacle.y + obstacle.height &&
      player.y + player.height > obstacle.y
    ) {
      obstacles.splice(index, 1);
      health--;
      if (health <= 0) {
        gameOver = true;
      }
    }

    // Remove off-screen obstacles
    if (obstacle.x + obstacle.width < 0) {
      obstacles.splice(index, 1);
    }
  });

  // Draw flying obstacles
  flyingObstacles.forEach((obstacle, index) => {
    obstacle.x -= gameSpeed;
    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

    // Collision detection for flying obstacles
    if (
      player.x < obstacle.x + obstacle.width &&
      player.x + player.width > obstacle.x &&
      player.y < obstacle.y + obstacle.height &&
      player.y + player.height > obstacle.y
    ) {
      flyingObstacles.splice(index, 1);
      health--;
      if (health <= 0) {
        gameOver = true;
      }
    }

    // Remove off-screen flying obstacles
    if (obstacle.x + obstacle.width < 0) {
      flyingObstacles.splice(index, 1);
    }
  });

  // Draw heal power-ups
  ctx.fillStyle = 'green';
  healPowerUps.forEach((powerUp, index) => {
    powerUp.x -= gameSpeed;
    ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);

    // Collision detection for heal power-ups
    if (
      player.x < powerUp.x + powerUp.width &&
      player.x + player.width > powerUp.x &&
      player.y < powerUp.y + powerUp.height &&
      player.y + player.height > powerUp.y
    ) {
      healPowerUps.splice(index, 1);
      if (health < maxHealth) {
        health++;
      }
    }

    // Remove off-screen power-ups
    if (powerUp.x + powerUp.width < 0) {
      healPowerUps.splice(index, 1);
    }
  });

  // Gravity
  player.dy += gravity;
  player.y += player.dy;

  // Prevent player from falling below ground
  if (player.y + player.height >= canvas.height - 100) {
    player.y = canvas.height - player.height - 100;
    player.dy = 0;
    player.jumps = 0;
  }

  // Spawn new obstacles based on interval
  if (obstacleInterval >= obstacleSpacing) {
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];

    if (pattern.ground) spawnGroundObstacle();
    if (pattern.flying) spawnFlyingObstacle(obstacleSpacing / 2);
    if (pattern.double) spawnGroundObstacle(100);

    obstacleInterval = 0;
  }
  obstacleInterval += gameSpeed;

  // Spawn new heal power-ups based on interval
  if (healPowerUpInterval >= healPowerUpSpacing) {
    spawnHealPowerUp();
    healPowerUpInterval = 0;
  }
  healPowerUpInterval += gameSpeed;

  // Display Health
  ctx.font = '20px Arial';
  ctx.fillStyle = 'black';
  ctx.fillText(`Health: ${health}`, 10, 30);

  // Display Distance
  ctx.fillText(`Distance: ${distance}`, 10, 60);

  requestAnimationFrame(gameLoop);
}
