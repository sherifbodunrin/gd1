// In your game loop, after drawing other elements like health and score
function gameLoop() {
  if (gameOver) {
    coins += Math.floor(distance); // Convert score to coins
    updateLobbyDisplay();
    lobby.style.display = 'flex';
    canvas.style.display = 'none';
    miniMap.style.display = 'none';
    return;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  miniCtx.clearRect(0, 0, miniMap.width, miniMap.height);
  
  // Update distance based on game speed
  distance += gameSpeed * 0.1;

  // Gradually increase game speed with a cap
  if (Math.floor(distance) % 100 === 0 && gameSpeed < maxGameSpeed) {
    gameSpeed += 0.01;
  }

  // Draw ground
  ctx.fillStyle = 'black';
  ctx.fillRect(0, canvas.height - 100, canvas.width, 10);

  // Draw player
  ctx.fillStyle = 'blue';
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Draw obstacles
  ctx.fillStyle = 'red';
  obstacles.forEach((obstacle, index) => {
    obstacle.x -= gameSpeed;
    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

    // Collision detection for ground obstacles
    if (
      player.x < obstacle.x + obstacle.width &&
      player.x + player.width > obstacle.x &&
      player.y < obstacle.y + obstacle.height &&
      player.y + player.height > obstacle.y
    ) {
      obstacles.splice(index, 1);
      health--;
      if (health <= 0) {
        gameOver = true;
      }
    }

    // Remove off-screen obstacles
    if (obstacle.x + obstacle.width < 0) {
      obstacles.splice(index, 1);
    }
  });

  // Draw flying obstacles
  flyingObstacles.forEach((obstacle, index) => {
    obstacle.x -= gameSpeed;
    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

    // Collision detection for flying obstacles
    if (
      player.x < obstacle.x + obstacle.width &&
      player.x + player.width > obstacle.x &&
      player.y < obstacle.y + obstacle.height &&
      player.y + player.height > obstacle.y
    ) {
      flyingObstacles.splice(index, 1);
      health--;
      if (health <= 0) {
        gameOver = true;
      }
    }

    // Remove off-screen flying obstacles
    if (obstacle.x + obstacle.width < 0) {
      flyingObstacles.splice(index, 1);
    }
  });

  // Draw heal power-ups
  ctx.fillStyle = 'green';
  healPowerUps.forEach((powerUp, index) => {
    powerUp.x -= gameSpeed;
    ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);

    // Collision detection for heal power-ups
    if (
      player.x < powerUp.x + powerUp.width &&
      player.x + player.width > powerUp.x &&
      player.y < powerUp.y + powerUp.height &&
      player.y + player.height > powerUp.y
    ) {
      healPowerUps.splice(index, 1);
      if (health < maxHealth) {
        health++;
      }
    }

    // Remove off-screen power-ups
    if (powerUp.x + powerUp.width < 0) {
      healPowerUps.splice(index, 1);
    }
  });

  // Gravity
  player.dy += gravity;
  player.y += player.dy;

  // Prevent player from falling below ground
  if (player.y + player.height >= canvas.height - 100) {
    player.y = canvas.height - player.height - 100;
    player.dy = 0;
    player.jumps = 0;
  }

  // Spawn new obstacles based on interval
  if (obstacleInterval >= obstacleSpacing) {
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
    
    if (pattern.ground) spawnGroundObstacle();
    if (pattern.flying) spawnFlyingObstacle(obstacleSpacing / 2);
    if (pattern.double) spawnGroundObstacle(100);

    obstacleInterval = 0;
  }
  obstacleInterval += gameSpeed;

  // Spawn new heal power-ups based on interval
  if (healPowerUpInterval >= healPowerUpSpacing) {
    spawnHealPowerUp();
    healPowerUpInterval = 0;
  }
  healPowerUpInterval += gameSpeed;

  // Display Health
  ctx.font = '20px Arial';
  ctx.fillStyle = 'black';
  ctx.fillText(`Health: ${health}`, 10, 30);

  // Display Distance as Score
  ctx.fillText(`Score: ${Math.floor(distance)}`, 10, 60);

  // Display Current Realm
  ctx.fillText(`Realm: ${currentRealm}`, 10, 90);

  requestAnimationFrame(gameLoop);
}
